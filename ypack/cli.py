"""
Command-line interface for xswl-YPack.

Subcommands
-----------
convert   Convert a YAML configuration to an installer script.
init      Generate a starter YAML configuration template.
validate  Validate a YAML configuration without generating output.
"""

from __future__ import annotations

import argparse
import os
import subprocess
import sys
import textwrap
from typing import List, Optional

from . import __version__
from .converters import BUILD_COMMANDS, OUTPUT_EXTENSIONS, SUPPORTED_FORMATS, get_converter_class


# -----------------------------------------------------------------------
# Template for ``ypack init``
# -----------------------------------------------------------------------

_INIT_TEMPLATE = textwrap.dedent("""\
    # xswl-YPack configuration — generated by `ypack init`
    app:
      name: "MyApp"
      version: "1.0.0"
      publisher: "My Company"
      description: "A short description of my application"
      # install_icon: "resources/app.ico"
      # license: "LICENSE.txt"

    install:
      install_dir: "$PROGRAMFILES64\\\\${APP_NAME}"
      desktop_shortcut_target: "$INSTDIR\\\\MyApp.exe"
      start_menu_shortcut_target: "$INSTDIR\\\\MyApp.exe"

    files:
      - "MyApp.exe"
      # - source: "lib/*"
      #   destination: "$INSTDIR\\\\lib"
      #   recursive: true

    languages:
      - English

    # signing:
    #   enabled: false
    #   certificate: "cert.pfx"
    #   password: ""

    # update:
    #   enabled: false
    #   update_url: "https://example.com/updates/latest.json"
""")

_FORMAT_CHOICES = SUPPORTED_FORMATS


# -----------------------------------------------------------------------
# CLI entry point
# -----------------------------------------------------------------------

def main(argv: Optional[List[str]] = None) -> None:
    """CLI entry point — called by the ``xswl-ypack`` console script."""
    parser = argparse.ArgumentParser(
        prog="xswl-ypack",
        description="xswl-YPack: Convert YAML configuration to installer scripts (NSIS, WIX, Inno Setup, …)",
    )
    parser.add_argument(
        "-V", "--version",
        action="version",
        version=f"%(prog)s {__version__}",
    )

    sub = parser.add_subparsers(dest="command")

    # -- convert ---------------------------------------------------------
    p_conv = sub.add_parser("convert", help="Convert YAML → installer script")
    p_conv.add_argument("config", help="Path to YAML configuration file")
    p_conv.add_argument("-f", "--format", default="nsis", choices=_FORMAT_CHOICES,
                        help="Target installer format (default: nsis)")
    p_conv.add_argument("-o", "--output", default=None,
                        help="Output script path (default: <config_dir>/installer.<ext>)")
    p_conv.add_argument("-b", "--build", action="store_true",
                        help="Build installer after script generation (format-specific)")
    p_conv.add_argument("--makensis", default="makensis",
                        help="Path to makensis executable (NSIS only)")
    p_conv.add_argument("-v", "--verbose", action="store_true")
    p_conv.add_argument("-n", "--dry-run", action="store_true",
                        help="Print generated script to stdout instead of writing a file")

    # -- init ------------------------------------------------------------
    p_init = sub.add_parser("init", help="Generate a starter YAML configuration")
    p_init.add_argument("-o", "--output", default="installer.yaml",
                        help="Output YAML path (default: installer.yaml)")

    # -- validate --------------------------------------------------------
    p_val = sub.add_parser("validate", help="Validate a YAML configuration")
    p_val.add_argument("config", help="Path to YAML configuration file")
    p_val.add_argument("-v", "--verbose", action="store_true")

    # -- legacy: bare positional arg (backward compat) -------------------
    args = parser.parse_args(argv)

    if args.command is None:
        # Support legacy invocation: ypack <config.yaml> [-o out.nsi]
        # Re-parse as convert
        if len(sys.argv) > 1 and not sys.argv[1].startswith("-"):
            args = p_conv.parse_args(sys.argv[1:])
            args.command = "convert"
        else:
            parser.print_help()
            sys.exit(0)

    try:
        if args.command == "convert":
            _cmd_convert(args)
        elif args.command == "init":
            _cmd_init(args)
        elif args.command == "validate":
            _cmd_validate(args)
    except Exception as exc:
        print(f"Error: {exc}", file=sys.stderr)
        if getattr(args, "verbose", False):
            import traceback
            traceback.print_exc()
        sys.exit(1)


# -----------------------------------------------------------------------
# Subcommand implementations
# -----------------------------------------------------------------------

def _cmd_convert(args: argparse.Namespace) -> None:
    from .config import PackageConfig

    fmt: str = getattr(args, "format", "nsis")

    if not os.path.exists(args.config):
        print(f"Error: Configuration file '{args.config}' not found", file=sys.stderr)
        sys.exit(1)

    # Determine default output path from format
    if args.output is None:
        config_dir = os.path.dirname(os.path.abspath(args.config))
        ext = OUTPUT_EXTENSIONS.get(fmt, ".nsi")
        args.output = os.path.join(config_dir, f"installer{ext}")

    if args.verbose:
        print(f"Loading configuration from {args.config} …")
    config = PackageConfig.from_yaml(args.config)

    converter_cls = get_converter_class(fmt)
    if args.verbose:
        print(f"Converting YAML → {fmt.upper()} …")
    converter = converter_cls(config, config._raw_dict)

    if args.dry_run:
        print(converter.convert())
        return

    if args.verbose:
        print(f"Writing {fmt.upper()} script to {args.output} …")
    converter.save(args.output)
    print(f"Generated {fmt.upper()} script: {args.output}")

    if args.build:
        _build(args, config, fmt)


def _cmd_init(args: argparse.Namespace) -> None:
    output = args.output
    if os.path.exists(output):
        print(f"Error: '{output}' already exists. Remove it first or choose a different name.", file=sys.stderr)
        sys.exit(1)
    with open(output, "w", encoding="utf-8") as fh:
        fh.write(_INIT_TEMPLATE)
    print(f"Created starter configuration: {output}")


def _cmd_validate(args: argparse.Namespace) -> None:
    from .config import PackageConfig

    if not os.path.exists(args.config):
        print(f"Error: Configuration file '{args.config}' not found", file=sys.stderr)
        sys.exit(1)

    # from_yaml already validates via schema
    config = PackageConfig.from_yaml(args.config)
    print(f"✓ Configuration is valid: {args.config}")
    if args.verbose:
        print(f"  App:      {config.app.name} {config.app.version}")
        print(f"  Files:    {len(config.files)}")
        print(f"  Packages: {len(config.packages)}")
        if config.signing and config.signing.enabled:
            print("  Signing:  enabled")
        if config.update and config.update.enabled:
            print("  Update:   enabled")


# -----------------------------------------------------------------------
# Build helper
# -----------------------------------------------------------------------

def _build(args: argparse.Namespace, config: object, fmt: str) -> None:
    """Invoke the external compiler for *fmt* (currently NSIS only)."""
    compiler_cmd = BUILD_COMMANDS.get(fmt)
    if compiler_cmd is None:
        print(f"Warning: --build is not yet supported for format '{fmt}'", file=sys.stderr)
        return

    # Allow user override for NSIS
    if fmt == "nsis":
        compiler_cmd = getattr(args, "makensis", compiler_cmd)

    if args.verbose:
        print(f"Building installer with {compiler_cmd} …")
    try:
        result = subprocess.run(
            [compiler_cmd, args.output],
            capture_output=True,
            text=True,
            check=True,
        )
        if args.verbose:
            print(result.stdout)
        installer = f"{config.app.name}-{config.app.version}-Setup.exe"  # type: ignore[attr-defined]
        print(f"Built installer: {installer}")
    except FileNotFoundError:
        print(f"Error: {compiler_cmd} not found. Install {fmt.upper()} or specify the correct path.", file=sys.stderr)
        sys.exit(1)
    except subprocess.CalledProcessError as exc:
        print("Error building installer:", file=sys.stderr)
        print(exc.stderr, file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
