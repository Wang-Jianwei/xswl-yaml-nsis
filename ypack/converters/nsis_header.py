"""
NSIS script header generation — defines, includes, unicode, icons.
"""

from __future__ import annotations

import os
from typing import List

from .context import BuildContext


def generate_header(ctx: BuildContext) -> List[str]:
    """Top-of-file defines, Unicode flag, MUI icon defines."""
    cfg = ctx.config
    lines: List[str] = [
        "; NSIS Script generated by xswl-YPack",
        "; Do not edit manually — regenerate from YAML configuration",
        "",
        "; --- Encoding ---",
        "Unicode true",
        "",
        "; --- Application Information ---",
        f'!define APP_NAME "{cfg.app.name}"',
        f'!define APP_VERSION "{cfg.app.version}"',
        f'!define APP_PUBLISHER "{cfg.app.publisher}"',
        f'!define APP_DESCRIPTION "{cfg.app.description}"',
        f'!define REG_KEY "Software\\{cfg.app.name}"',
        "",
    ]

    # MUI icon defines (must appear before !include MUI2.nsh)
    install_icon = cfg.app.install_icon
    uninstall_icon = cfg.app.uninstall_icon or install_icon
    if install_icon or uninstall_icon:
        lines.append("; --- Modern UI Icons ---")
        if install_icon:
            abs_path = ctx.resolve_path(install_icon)
            rel_path = ctx.relative_to_output(abs_path) if os.path.exists(abs_path) else install_icon
            if not os.path.exists(abs_path):
                lines.append(f"; WARNING: Install icon not found: {install_icon}")
            lines.append(f'!define MUI_ICON "{rel_path}"')
        if uninstall_icon:
            abs_path = ctx.resolve_path(uninstall_icon)
            rel_path = ctx.relative_to_output(abs_path) if os.path.exists(abs_path) else uninstall_icon
            if not os.path.exists(abs_path):
                lines.append(f"; WARNING: Uninstall icon not found: {uninstall_icon}")
            lines.append(f'!define MUI_UNICON "{rel_path}"')
        lines.append("")

    # License file (put near top with other top-level defines)
    if cfg.app.license:
        abs_path = ctx.resolve_path(cfg.app.license)
        if os.path.exists(abs_path):
            rel_path = ctx.relative_to_output(abs_path)
            lines.append(f'!define LICENSE_FILE "{rel_path}"')
        else:
            lines.append(f"; WARNING: License file not found: {cfg.app.license}")
            lines.append(f'!define LICENSE_FILE "{cfg.app.license}"')

    return lines


def generate_custom_includes(ctx: BuildContext) -> List[str]:
    """Emit ``!include`` directives from ``custom_includes.nsis``."""
    includes = []
    ci = ctx.config.custom_includes
    if isinstance(ci, dict):
        includes = list(ci.get("nsis", []))
    if not includes:
        return []
    lines = ["; --- Custom NSIS Includes ---"]
    for inc in includes:
        lines.append(f'!include "{inc}"')
    lines.append("")
    return lines


def generate_general_settings(ctx: BuildContext) -> List[str]:
    """Name, OutFile, InstallDir, RequestExecutionLevel, license."""
    cfg = ctx.config
    lines: List[str] = [
        "; --- General Settings ---",
        f'Name "${{APP_NAME}}"',
        f'OutFile "${{APP_NAME}}-${{APP_VERSION}}-Setup.exe"',
        f'InstallDir "{ctx.resolve(cfg.install.install_dir)}"',
        'InstallDirRegKey HKLM "${REG_KEY}" "InstallPath"',
        'RequestExecutionLevel admin',
    ]

    # License data belongs to general settings (keeps settings grouped together)
    if cfg.app.license:
        lines.append('LicenseData "${LICENSE_FILE}"')

    # Silent install support
    if cfg.install.silent_install:
        lines.append("SilentInstall silent")

    # Logging
    if cfg.logging and cfg.logging.enabled:
        log_path = cfg.logging.path or "$APPDATA\\${APP_NAME}\\install.log"
        resolved_path = ctx.resolve(cfg.logging.path) if cfg.logging.path else log_path
        lines.append(f'; Logging: {resolved_path} (level={cfg.logging.level})')
        lines.append(f'!define LOG_FILE "{resolved_path}"')

    # Utility includes (provide helper macros used elsewhere, e.g. ${GetSize})
    lines.append('!include "FileFunc.nsh"')

    lines.append("")
    return lines


def generate_modern_ui(ctx: BuildContext) -> List[str]:
    """MUI2 include, page macros, language macros, finish-page run."""
    cfg = ctx.config
    lines: List[str] = [
        "; --- Modern UI ---",
        '!include "MUI2.nsh"',
        "",
    ]

    # Finish page run checkbox — MUST be defined BEFORE MUI_PAGE_FINISH macro
    launch = cfg.install.launch_on_finish
    if launch:
        path = ctx.resolve(launch)
        lines.append("; Finish page run (launch on finish)")
        lines.append(f'!define MUI_FINISHPAGE_RUN "{path}"')
        label = cfg.install.launch_on_finish_label
        if label:
            label_resolved = ctx.resolve(label)
            lines.append(f'!define MUI_FINISHPAGE_RUN_TEXT "{label_resolved}"')
        lines.append("")

    # UI Pages
    lines.append("; UI Pages")
    if cfg.app.license:
        lines.append('!insertmacro MUI_PAGE_LICENSE "${LICENSE_FILE}"')
    else:
        lines.append("; No license page")

    if cfg.packages:
        lines.append("!insertmacro MUI_PAGE_COMPONENTS")

    lines.extend([
        "!insertmacro MUI_PAGE_DIRECTORY",
        "!insertmacro MUI_PAGE_INSTFILES",
        "!insertmacro MUI_PAGE_FINISH",
        "",
        "!insertmacro MUI_UNPAGE_CONFIRM",
        "!insertmacro MUI_UNPAGE_INSTFILES",
        "",
    ])

    # Languages
    langs = cfg.languages or ["English"]
    for lang in langs:
        lines.append(f'!insertmacro MUI_LANGUAGE "{lang}"')
    lines.append("")

    return lines
