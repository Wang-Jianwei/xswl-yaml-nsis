"""
YAML to NSIS script converter
"""

import os
import re
from typing import List

from .base import BaseConverter
from ..config import PackageConfig


class YamlToNsisConverter(BaseConverter):
    """Converts YAML configuration to NSIS script"""

    tool_name = "nsis"

    def __init__(self, config: PackageConfig):
        super().__init__(config)

    def _replace_variables(self, text: str) -> str:
        """Replace variable placeholders with actual values"""
        replacements = {
            "${APP_NAME}": self.config.app.name,
            "${APP_VERSION}": self.config.app.version,
            "${APP_PUBLISHER}": self.config.app.publisher,
        }
        for var, value in replacements.items():
            text = text.replace(var, value)
        return text

    def _interpolate_yaml_placeholders(self, text: str) -> str:
        """Replace YAML placeholders with config values dynamically.

        Supports placeholders like {app_name}, {app.name}, {install.install_dir}, etc.
        Searches for patterns {key} or {object.attribute.nested} and resolves from config.

        Args:
            text: Text with {placeholder} style placeholders

        Returns:
            Text with placeholders replaced by actual values
        """
        if not text:
            return text

        # Find all {placeholder} patterns
        pattern = r'\{([^}]+)\}'

        def replace_placeholder(match):
            placeholder = match.group(1)
            try:
                # Try to get value from config using dot notation
                obj = self.config
                for attr in placeholder.split('.'):
                    obj = getattr(obj, attr, None)
                    if obj is None:
                        return match.group(0)  # Return original if not found
                return str(obj) if obj is not None else match.group(0)
            except (AttributeError, TypeError):
                return match.group(0)  # Return original if error

        return re.sub(pattern, replace_placeholder, text)

    def _normalize_path(self, path: str) -> str:
        """Convert Python-style paths to NSIS-compatible Windows paths.

        Converts:
        - Forward slashes (/) to backslashes (\\)
        - Double asterisks (**) to single asterisks (*)

        Args:
            path: Path string (may use / or **/ for recursion)

        Returns:
            NSIS-compatible Windows path
        """
        # Replace Python-style recursive glob with single asterisk
        path = path.replace("/**/", "\\")
        path = path.replace("**/", "")

        # Replace forward slashes with backslashes
        path = path.replace("/", "\\")

        return path

    def _should_use_recursive(self, source: str) -> bool:
        """Determine if File /r should be used based on the source pattern.

        Only treat patterns containing "**" as recursive. Single-level "*" (e.g. "dir/*")
        is considered non-recursive to follow common glob semantics.
        """
        if not source:
            return False
        return "**" in source

    def _generate_header(self) -> List[str]:
        """Generate NSIS header section with MUI definitions"""
        lines = [
            "; NSIS Script generated by xswl-YPack",
            "; Do not edit manually - regenerate from YAML configuration",
            "",
            "; Application Information",
            f'!define APP_NAME "{self.config.app.name}"',
            f'!define APP_VERSION "{self.config.app.version}"',
            f'!define APP_PUBLISHER "{self.config.app.publisher}"',
            f'!define APP_DESCRIPTION "{self.config.app.description}"',
            f'!define REG_KEY "Software\\{self.config.app.name}"',
            "",
        ]

        # Add MUI icon definitions (must be before MUI2.nsh include)
        if self.config.app.icon:
            abs_icon_path = self._resolve_path_relative_to_config(self.config.app.icon)
            rel_icon_path = self._get_relative_path_for_nsi(abs_icon_path) if os.path.exists(abs_icon_path) else self.config.app.icon

            lines.append("; Modern UI Icons")
            if not os.path.exists(abs_icon_path):
                lines.append(f"; Warning: Icon file not found: {self.config.app.icon}")
            lines.append(f'!define MUI_ICON "{rel_icon_path}"')
            lines.append(f'!define MUI_UNICON "{rel_icon_path}"')
            lines.append("")

        # If any env vars request append behavior, emit helper functions (Contains & RemovePathEntry)
        envs = getattr(self.config.install, 'env_vars', []) if getattr(self.config, 'install', None) else []
        if any(getattr(e, 'append', False) for e in envs):
            lines.append('; Helper: check if a substring exists in a string (sets $R9 to 1 if found, 0 otherwise; $R8 = index)')
            lines.extend([
                'Function _Contains',
                '  ; $0 = haystack, $1 = needle',
                '  StrCpy $R9 0',
                '  StrCpy $R8 -1',
                '  StrLen $R2 $0',
                '  StrLen $R3 $1',
                '  IntCmp $R3 0 0 +4',
                '    StrCpy $R9 1',
                '    StrCpy $R8 0',
                '    Return',
                '  IntOp $R4 $R2 - $R3',
                '  StrCpy $R5 0',
                '  loop_find:',
                '  IntCmp $R5 $R4 +3 0 0',
                '  StrCpy $R6 $0 $R3 $R5',
                '  StrCmp $R6 $1 found_find',
                '  IntOp $R5 $R5 + 1',
                '  Goto loop_find',
                '  found_find:',
                '  StrCpy $R9 1',
                '  StrCpy $R8 $R5',
                '  Return',
                'FunctionEnd',
                '',
                '; Helper: normalize a PATH entry (convert slashes, trim, uppercase using system call) and remove duplicate separators',
                'Function _NormalizePathEntry',
                '  ; $0 = input path or PATH string (in-place normalization)',
                '  ; Convert forward slashes to backslashes',
                '  StrReplace $0 "/" "\\"',
                '  ; Trim surrounding spaces',
                '  ; (Simple trim implementation) ',
                '  StrCpy $R0 $0',
                '  ; Upper-case using CharUpperBuffA for case-insensitive comparison',
                '  System::Call "kernel32::CharUpperBuffA(t, i) i .r1"',
                '  ; Remove duplicate semicolons',
                '  loop_trim_semi:',
                '  StrReplace $0 ";;" ";"',
                '  StrCmp $R1 $R0 0 +2',
                '  Goto loop_trim_semi',
                'FunctionEnd',
                '',
                '; Helper: remove an exact path entry from a PATH-like string (in $0) using the index found by _Contains',
                'Function _RemovePathEntry',
                '  ; $0 = original PATH, $1 = entry to remove',
                '  Call _NormalizePathEntry',
                '  StrCpy $0 ";$0;"',
                '  Call _NormalizePathEntry',
                '  StrCpy $1 ";$1;"',
                '  ; Loop until no occurrence remains',
                '  loop_remove:',
                '  StrCpy $2 $0',
                '  StrCpy $3 $1',
                '  Call _Contains',
                '  StrCmp $R9 "1" 0 +6',
                '    ; Found at $R8; remove substring at $R8 of length len($R1)',
                '    StrLen $R2 $R1',
                '    ; prefix',
                '    StrCpy $R3 $R0 $R8 0',
                '    ; suffix',
                '    IntOp $R4 $R8 + $R2',
                '    StrLen $R5 $R0',
                '    IntOp $R6 $R5 - $R4',
                '    StrCpy $R4 $R0 $R6 $R4',
                '    StrCpy $0 "$R3$R4"',
                '    Goto loop_remove',
                '  ; Trim leading/trailing semicolons',
                '  StrLen $R7 $R0',
                '  IntOp $R7 $R7 - 2',
                '  StrCpy $0 $R0 $R7 1',
                'FunctionEnd',
                ''
            ])

        return lines

    def _resolve_path_relative_to_config(self, path: str) -> str:
        """Resolve a path relative to the YAML config directory if necessary.
        Returns absolute path if found, otherwise returns original path string."""
        if not path:
            return path
        # If absolute or exists as-is, return absolute
        if os.path.isabs(path) and os.path.exists(path):
            return os.path.abspath(path)
        if os.path.exists(path):
            return os.path.abspath(path)
        # Try relative to config directory if configured
        cfg_dir = getattr(self.config, '_config_dir', None)
        if cfg_dir:
            candidate = os.path.abspath(os.path.join(cfg_dir, path))
            if os.path.exists(candidate):
                return candidate
        # Not found; return original
        return path

    def _get_relative_path_for_nsi(self, file_path: str, nsi_dir: str = None) -> str:
        """Convert absolute file path to relative path suitable for NSIS script.

        If file is in the same directory as the .nsi file, returns just the filename.
        Otherwise returns the path relative to the .nsi directory.

        Args:
            file_path: Absolute or relative path to the file
            nsi_dir: Directory where .nsi file is located. If None, uses config._config_dir

        Returns:
            Path suitable for inclusion in NSIS script (forward slashes converted to backslashes)
        """
        if not file_path:
            return file_path

        # Resolve to absolute path
        abs_path = self._resolve_path_relative_to_config(file_path)

        # Get NSIS output directory (config directory by default)
        if nsi_dir is None:
            nsi_dir = getattr(self.config, '_config_dir', os.getcwd())

        # Compute relative path from .nsi directory to file
        try:
            rel_path = os.path.relpath(abs_path, nsi_dir)
            # Normalize path for NSIS (forward slashes to backslashes)
            rel_path = rel_path.replace('/', '\\')
            return rel_path
        except ValueError:
            # Different drives on Windows - return as-is with backslashes
            return abs_path.replace('/', '\\')

    def _generate_general_settings(self) -> List[str]:
        """Generate general NSIS settings"""
        lines = [
            "; General Settings",
            f'Name "${{APP_NAME}}"',
            f'OutFile "${{APP_NAME}}-${{APP_VERSION}}-Setup.exe"',
            f'InstallDir "{self._interpolate_yaml_placeholders(self.config.install.install_dir)}"',
            'InstallDirRegKey HKLM "${REG_KEY}" "InstallPath"',
            'RequestExecutionLevel admin',
        ]

        # Add license if specified - use relative path for NSIS
        if self.config.app.license:
            abs_license_path = self._resolve_path_relative_to_config(self.config.app.license)
            if os.path.exists(abs_license_path):
                rel_license_path = self._get_relative_path_for_nsi(abs_license_path)
                lines.append(f'!define LICENSE_FILE "{rel_license_path}"')
                lines.append(f'LicenseData "${{LICENSE_FILE}}"')
            else:
                lines.append(f'; Warning: License file not found: {self.config.app.license}')
                lines.append(f'!define LICENSE_FILE "{self.config.app.license}"')
                lines.append(f'LicenseData "${{LICENSE_FILE}}"')

        lines.append("")
        return lines

    def _generate_modern_ui(self) -> List[str]:
        """Generate Modern UI configuration"""
        lines = [
            "; Modern UI",
            '!include "MUI2.nsh"',
            "",
            "; UI Pages",
            "!insertmacro MUI_PAGE_LICENSE \"${LICENSE_FILE}\"" if self.config.app.license else "; No license page",
        ]

        # Add components page if packages are defined
        if self.config.packages:
            lines.append("!insertmacro MUI_PAGE_COMPONENTS")

        lines.extend([
            "!insertmacro MUI_PAGE_DIRECTORY",
            "!insertmacro MUI_PAGE_INSTFILES",
            "!insertmacro MUI_PAGE_FINISH",
            "",
            "!insertmacro MUI_UNPAGE_CONFIRM",
            "!insertmacro MUI_UNPAGE_INSTFILES",
            "",
        ])
        # Emit language macros based on configuration (defaults to English)
        langs = getattr(self.config, 'languages', None)
        if langs:
            for lang in langs:
                lines.append(f'!insertmacro MUI_LANGUAGE "{lang}"')
            lines.append("")
        else:
            lines.append('!insertmacro MUI_LANGUAGE "English"')
            lines.append("")
        return lines

    def _generate_installer_section(self) -> List[str]:
        """Generate installer section"""
        lines = [
            "; Installer Section",
            "Section \"Install\"",
            "",
            "  SetOutPath $INSTDIR",
            "",
        ]

        # Add files
        for file_entry in self.config.files:
            normalized_source = self._normalize_path(file_entry.source)
            if self._should_use_recursive(file_entry.source):
                lines.append(f'  File /r "{normalized_source}"')
            else:
                lines.append(f'  File "{normalized_source}"')
            if file_entry.destination != "$INSTDIR":
                lines.append(f'  ; Install to: {file_entry.destination}')

        lines.extend([
            "",
            "  ; Write uninstaller",
            '  WriteUninstaller "$INSTDIR\\Uninstall.exe"',
            "",
        ])

        # Registry entries
        lines.extend([
            "  ; Registry entries",
            '  WriteRegStr HKLM "${REG_KEY}" "InstallPath" "$INSTDIR"',
            '  WriteRegStr HKLM "${REG_KEY}" "Version" "${APP_VERSION}"',
            '  WriteRegStr HKLM "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${APP_NAME}" "DisplayName" "${APP_NAME}"',
            '  WriteRegStr HKLM "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${APP_NAME}" "UninstallString" "$INSTDIR\\Uninstall.exe"',
            '  WriteRegStr HKLM "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${APP_NAME}" "DisplayVersion" "${APP_VERSION}"',
            '  WriteRegStr HKLM "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${APP_NAME}" "Publisher" "${APP_PUBLISHER}"',
            "",
        ])

        # Custom registry entries from config
        views_used = set([e.view for e in self.config.install.registry_entries if getattr(e, 'view', 'auto') and e.view != 'auto'])
        if len(views_used) > 1:
            views_list = ",".join(sorted(views_used))
            lines.append('  ; ============================================================')
            lines.append(f'  ; WARNING: registry entries use multiple SetRegView values: {views_list}')
            lines.append('  ; Converter will insert SetRegView before each affected entry.')
            lines.append('  ; Be aware: SetRegView affects subsequent registry operations.')
            lines.append('  ; ============================================================')
        for entry in self.config.install.registry_entries:
            # interpolate YAML placeholders if present
            value = self._interpolate_yaml_placeholders(entry.value)
            # Handle registry view if specified
            if entry.view in ("32", "64"):
                lines.append(f'  SetRegView {entry.view}')
            if entry.type == "string":
                lines.append(f'  WriteRegStr {entry.hive} "{entry.key}" "{entry.name}" "{value}"')
            elif entry.type == "expand":
                lines.append(f'  WriteRegExpandStr {entry.hive} "{entry.key}" "{entry.name}" "{value}"')
            elif entry.type == "dword":
                # dword value should be numeric
                lines.append(f'  WriteRegDWORD {entry.hive} "{entry.key}" "{entry.name}" {value}')
            else:
                lines.append(f'  ; Unsupported registry type: {entry.type} for {entry.name}')

        # Environment variables
        for env in getattr(self.config.install, 'env_vars', []):
            env_value = self._interpolate_yaml_placeholders(env.value)
            scope = (env.scope or "system").lower()
            if scope == 'system':
                hive = 'HKLM'
                key = 'SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment'
            else:
                hive = 'HKCU'
                key = 'Environment'

            lines.append(f'  ; Environment variable: {env.name} ({env.scope})')

            # PATH append behavior: read current PATH and append if not present
            if env.append and env.name.upper() == 'PATH':
                lines.append(f'  ReadRegStr $0 {hive} "{key}" "{env.name}"')
                lines.append(f'  StrCpy $1 "{env_value}"')
                lines.append('  ; Normalize PATH and entry for robust comparison')
                lines.append('  Call _NormalizePathEntry  ; normalize current PATH in $0')
                lines.append('  StrCpy $2 $1')
                lines.append('  StrCpy $0 $2')
                lines.append('  Call _NormalizePathEntry  ; normalize candidate entry in $0')
                lines.append('  StrCpy $1 $0')
                lines.append('  StrCpy $0 $2  ; restore PATH into $0 for semicolon-wrapping')
                lines.append('  ; Append PATH entry if not present (normalize and check with _Contains)')
                lines.append('  StrCpy $0 ";$0;"')
                lines.append('  StrCpy $1 ";$1;"')
                lines.append('  Call _Contains')
                lines.append('  StrCmp $R9 "1" 0 +6')
                lines.append(f'  ; Already present: skip append for {env.name}')
                lines.append('  Goto _skip_append')
                lines.append('  ; Append and write back')
                lines.append('  StrCpy $0 "$0$1"')
                lines.append('  ; Remove extra leading/trailing semicolons')
                lines.append('  StrLen $R2 $0')
                lines.append('  IntOp $R2 $R2 - 2')
                lines.append('  StrCpy $0 $0 $R2 1')
                lines.append(f'  WriteRegStr {hive} "{key}" "{env.name}" "$0"')
                lines.append('  ; Broadcast environment change so PATH becomes effective')
                lines.append('  System::Call "User32::SendMessageTimeoutA(i 0xffff, i 0x1A, i 0, t \"Environment\", i 0x2, i 500, *i .r0)"')
                lines.append('_skip_append:')
            else:
                if env.append:
                    lines.append(f'  ; append=True specified for {env.name} but only PATH append is implemented; setting value directly')
                lines.append(f'  WriteRegStr {hive} "{key}" "{env.name}" "{env_value}"')

        # Desktop shortcut
        if self.config.install.create_desktop_shortcut:
            lines.extend([
                "  ; Create desktop shortcut",
                '  CreateShortCut "$DESKTOP\\${APP_NAME}.lnk" "$INSTDIR\\${APP_NAME}.exe"',
                "",
            ])

        # Start menu shortcut
        if self.config.install.create_start_menu_shortcut:
            lines.extend([
                "  ; Create start menu shortcuts",
                '  CreateDirectory "$SMPROGRAMS\\${APP_NAME}"',
                '  CreateShortCut "$SMPROGRAMS\\${APP_NAME}\\${APP_NAME}.lnk" "$INSTDIR\\${APP_NAME}.exe"',
                '  CreateShortCut "$SMPROGRAMS\\${APP_NAME}\\Uninstall.lnk" "$INSTDIR\\Uninstall.exe"',
                "",
            ])

        lines.append("SectionEnd")
        lines.append("")

        return lines

    def _generate_uninstaller_section(self) -> List[str]:
        """Generate uninstaller section"""
        lines = [
            "; Uninstaller Section",
            "Section \"Uninstall\"",
            "",
            "  ; Remove files",
        ]

        # Remove files from regular files list (in reverse order)
        for file_entry in reversed(self.config.files):
            filename = os.path.basename(file_entry.source)
            if file_entry.recursive:
                # For recursive, remove the directory
                dirname = os.path.basename(file_entry.source.rstrip('/\\'))
                lines.append(f'  RMDir /r "$INSTDIR\\{dirname}"')
            else:
                lines.append(f'  Delete "$INSTDIR\\{filename}"')

        lines.extend([
            "",
            "  ; Remove uninstaller",
            '  Delete "$INSTDIR\\Uninstall.exe"',
            "",
            "  ; Remove install directory",
            '  RMDir "$INSTDIR"',
            "",
        ])

        # Remove shortcuts
        if self.config.install.create_desktop_shortcut:
            lines.extend([
                "  ; Remove desktop shortcut",
                '  Delete "$DESKTOP\\${APP_NAME}.lnk"',
                "",
            ])

        if self.config.install.create_start_menu_shortcut:
            lines.extend([
                "  ; Remove start menu shortcuts",
                '  Delete "$SMPROGRAMS\\${APP_NAME}\\${APP_NAME}.lnk"',
                '  Delete "$SMPROGRAMS\\${APP_NAME}\\Uninstall.lnk"',
                '  RMDir "$SMPROGRAMS\\${APP_NAME}"',
                "",
            ])

        # Remove registry entries
        lines.extend([
            "  ; Remove registry entries",
            '  DeleteRegKey HKLM "${REG_KEY}"',
            '  DeleteRegKey HKLM "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${APP_NAME}"',
            "",
        ])

        # Remove custom registry values defined in config
        for entry in self.config.install.registry_entries:
            if entry.view in ("32", "64"):
                lines.append(f'  SetRegView {entry.view}')
            lines.append(f'  DeleteRegValue {entry.hive} "{entry.key}" "{entry.name}"')

        # Remove environment variables defined in config (if requested)
        for env in getattr(self.config.install, 'env_vars', []):
            if not getattr(env, 'remove_on_uninstall', True):
                continue
            scope = (env.scope or "system").lower()
            if scope == 'system':
                hive = 'HKLM'
                key = 'SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment'
            else:
                hive = 'HKCU'
                key = 'Environment'

            # If PATH and append was used, call helper to remove the exact entry; otherwise delete value
            if getattr(env, 'append', False) and env.name.upper() == 'PATH':
                lines.append(f'  ReadRegStr $0 {hive} "{key}" "{env.name}"')
                lines.append(f'  StrCpy $1 "{self._interpolate_yaml_placeholders(env.value)}"')
                lines.append('  ; Remove the exact entry (if present)')
                lines.append('  StrCpy $0 ";$0;"')
                lines.append('  StrCpy $1 ";$1;"')
                lines.append('  Call _RemovePathEntry')
                lines.append('  ; Trim and write back')
                lines.append('  StrLen $R2 $0')
                lines.append('  IntOp $R2 $R2 - 2')
                lines.append('  StrCpy $0 $0 $R2 1')
                lines.append(f'  WriteRegStr {hive} "{key}" "{env.name}" "$0"')
                lines.append('  System::Call "User32::SendMessageTimeoutA(i 0xffff, i 0x1A, i 0, t \"Environment\", i 0x2, i 500, *i .r0)"')
            else:
                lines.append(f'  DeleteRegValue {hive} "{key}" "{env.name}"')

        lines.extend([
            "SectionEnd",
            "",
        ])

        return lines

    def _generate_signing_section(self) -> List[str]:
        """Generate code signing commands"""
        if not self.config.signing or not self.config.signing.enabled:
            return []

        lines = [
            "; Code Signing Configuration",
            f'; Certificate: {self.config.signing.certificate}',
            f'; Timestamp: {self.config.signing.timestamp_url}',
            "; Note: Use !finalize to sign the installer after build",
            f'!finalize \'signtool sign /f "{self.config.signing.certificate}" /p "{self.config.signing.password}" /t "{self.config.signing.timestamp_url}" "%1"\'',
            "",
        ]
        return lines

    def _generate_update_section(self) -> List[str]:
        """Generate auto-update configuration"""
        if not self.config.update or not self.config.update.enabled:
            return []

        lines = [
            "; Auto-Update Configuration",
            f'!define UPDATE_URL "{self.config.update.update_url}"',
            f'!define CHECK_ON_STARTUP "{str(self.config.update.check_on_startup).lower()}"',
            "",
            "; Note: Auto-update logic should be implemented in the application",
            "; The installer only sets registry values for the application to read",
            "Section \"Update Configuration\"",
            '  WriteRegStr HKLM "${REG_KEY}" "UpdateURL" "${UPDATE_URL}"',
            '  WriteRegStr HKLM "${REG_KEY}" "CheckOnStartup" "${CHECK_ON_STARTUP}"',
            "SectionEnd",
            "",
        ]
        return lines

    def _generate_package_sections(self) -> List[str]:
        """Generate sections for each package/component"""
        if not self.config.packages:
            return []

        lines = [
            "; Package/Component Sections",
            "",
        ]

        def _make_file_line(pkg_entry, s):
            resolved = self._resolve_path_relative_to_config(s)
            if os.path.exists(resolved):
                path_for_nsi = resolved
            else:
                path_for_nsi = self._normalize_path(s)
            if self._should_use_recursive(s):
                return f'  File /r "{path_for_nsi}"'
            return f'  File "{path_for_nsi}"'

        def _emit_package_section(pkg_entry, sec_name):
            lines.append(f'Section "{pkg_entry.name}" {sec_name}')
            for source_entry in pkg_entry.sources:
                source_value = source_entry.get("source", "")
                dest_path = source_entry.get("destination", "$INSTDIR")
                lines.append(f'  SetOutPath "{dest_path}"')

                if isinstance(source_value, list):
                    for s in source_value:
                        lines.append(_make_file_line(pkg_entry, s))
                else:
                    lines.append(_make_file_line(pkg_entry, source_value))
            if pkg_entry.post_install:
                lines.append("")
                lines.append("  ; Post-install commands")
                for cmd in pkg_entry.post_install:
                    lines.append(f'  ExecWait "{cmd}"')
            lines.append("SectionEnd")
            lines.append("")

        def _emit_group_or_section(pkg_list, idx_ref):
            for pkg_entry in pkg_list:
                if pkg_entry.children:
                    lines.append(f'SectionGroup "{pkg_entry.name}"')
                    _emit_group_or_section(pkg_entry.children, idx_ref)
                    lines.append("SectionGroupEnd")
                    lines.append("")
                else:
                    sec_name = f"SEC_PKG_{idx_ref[0]}"
                    idx_ref[0] += 1
                    _emit_package_section(pkg_entry, sec_name)

        _emit_group_or_section(self.config.packages, [0])
        return lines

    def _generate_section_initialization(self) -> List[str]:
        """Generate initialization code for section flags (optional, default settings)"""
        if not self.config.packages:
            return []

        lines = [
            "; Section Flags - Control default selection state",
            "Function .onInit",
            "",
        ]

        for idx, pkg in enumerate(self._flatten_packages(self.config.packages)):
            sec_name = f"SEC_PKG_{idx}"
            if pkg.optional and not pkg.default:
                # Optional and NOT default -> unselect by default
                lines.append(f'  SectionSetFlags ${{{sec_name}}} 0')
            elif not pkg.optional:
                # Required -> keep selected
                lines.append(f'  SectionSetFlags ${{{sec_name}}} ${{SF_SELECTED}}')

        lines.extend([
            "FunctionEnd",
            "",
        ])

        return lines

    def _flatten_packages(self, packages):
        """Return leaf packages in traversal order (ignore groups)."""
        flat = []
        for pkg in packages:
            if pkg.children:
                flat.extend(self._flatten_packages(pkg.children))
            else:
                flat.append(pkg)
        return flat

    def _generate_custom_includes(self) -> List[str]:
        """Generate custom NSIS includes"""
        if not self.config.custom_nsis_includes:
            return []

        lines = [
            "; Custom NSIS Includes",
        ]
        for include_file in self.config.custom_nsis_includes:
            lines.append(f'!include "{include_file}"')
        lines.append("")

        return lines

    def convert(self) -> str:
        """Convert YAML configuration to NSIS script"""
        nsis_lines = []

        # Add all sections
        nsis_lines.extend(self._generate_header())
        nsis_lines.extend(self._generate_custom_includes())
        nsis_lines.extend(self._generate_general_settings())
        nsis_lines.extend(self._generate_modern_ui())
        nsis_lines.extend(self._generate_signing_section())
        nsis_lines.extend(self._generate_update_section())
        nsis_lines.extend(self._generate_installer_section())
        nsis_lines.extend(self._generate_package_sections())
        nsis_lines.extend(self._generate_uninstaller_section())
        nsis_lines.extend(self._generate_section_initialization())

        return "\n".join(nsis_lines)

    def save(self, output_path: str) -> None:
        """Save NSIS script to file"""
        nsis_script = self.convert()
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(nsis_script)