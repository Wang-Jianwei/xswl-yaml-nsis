"""
YAML to NSIS script converter
"""

import os
import re
from typing import List
from .config import PackageConfig


class YamlToNsisConverter:
    """Converts YAML configuration to NSIS script"""
    
    def __init__(self, config: PackageConfig):
        self.config = config
    
    def _replace_variables(self, text: str) -> str:
        """Replace variable placeholders with actual values"""
        replacements = {
            "${APP_NAME}": self.config.app.name,
            "${APP_VERSION}": self.config.app.version,
            "${APP_PUBLISHER}": self.config.app.publisher,
        }
        for var, value in replacements.items():
            text = text.replace(var, value)
        return text
    
    def _interpolate_yaml_placeholders(self, text: str) -> str:
        """Replace YAML placeholders with config values dynamically.
        
        Supports placeholders like {app_name}, {app.name}, {install.install_dir}, etc.
        Searches for patterns {key} or {object.attribute.nested} and resolves from config.
        
        Args:
            text: Text with {placeholder} style placeholders
            
        Returns:
            Text with placeholders replaced by actual values
        """
        if not text:
            return text
        
        # Find all {placeholder} patterns
        pattern = r'\{([^}]+)\}'
        
        def replace_placeholder(match):
            placeholder = match.group(1)
            try:
                # Try to get value from config using dot notation
                obj = self.config
                for attr in placeholder.split('.'):
                    obj = getattr(obj, attr, None)
                    if obj is None:
                        return match.group(0)  # Return original if not found
                return str(obj) if obj is not None else match.group(0)
            except (AttributeError, TypeError):
                return match.group(0)  # Return original if error
        
        return re.sub(pattern, replace_placeholder, text)
    
    def _normalize_path(self, path: str) -> str:
        """Convert Python-style paths to NSIS-compatible Windows paths.
        
        Converts:
        - Forward slashes (/) to backslashes (\\)
        - Double asterisks (**) to single asterisks (*)
        
        Args:
            path: Path string (may use / or **/ for recursion)
            
        Returns:
            NSIS-compatible Windows path
        """
        # Replace Python-style recursive glob with single asterisk
        path = path.replace("/**/", "\\")
        path = path.replace("**/", "")
        
        # Replace forward slashes with backslashes
        path = path.replace("/", "\\")
        
        return path
    
    def _generate_header(self) -> List[str]:
        """Generate NSIS header section with MUI definitions"""
        lines = [
            "; NSIS Script generated by xswl-yaml-nsis",
            "; Do not edit manually - regenerate from YAML configuration",
            "",
            "; Application Information",
            f'!define APP_NAME "{self.config.app.name}"',
            f'!define APP_VERSION "{self.config.app.version}"',
            f'!define APP_PUBLISHER "{self.config.app.publisher}"',
            f'!define APP_DESCRIPTION "{self.config.app.description}"',
            f'!define REG_KEY "Software\\{self.config.app.name}"',
            "",
        ]
        
        # Add MUI icon definitions (must be before MUI2.nsh include)
        if self.config.app.icon:
            abs_icon_path = self._resolve_path_relative_to_config(self.config.app.icon)
            rel_icon_path = self._get_relative_path_for_nsi(abs_icon_path) if os.path.exists(abs_icon_path) else self.config.app.icon
            
            lines.append("; Modern UI Icons")
            if not os.path.exists(abs_icon_path):
                lines.append(f"; Warning: Icon file not found: {self.config.app.icon}")
            lines.append(f'!define MUI_ICON "{rel_icon_path}"')
            lines.append(f'!define MUI_UNICON "{rel_icon_path}"')
            lines.append("")
        
        return lines
    
    def _resolve_path_relative_to_config(self, path: str) -> str:
        """Resolve a path relative to the YAML config directory if necessary.
        Returns absolute path if found, otherwise returns original path string."""
        if not path:
            return path
        # If absolute or exists as-is, return absolute
        if os.path.isabs(path) and os.path.exists(path):
            return os.path.abspath(path)
        if os.path.exists(path):
            return os.path.abspath(path)
        # Try relative to config directory if configured
        cfg_dir = getattr(self.config, '_config_dir', None)
        if cfg_dir:
            candidate = os.path.abspath(os.path.join(cfg_dir, path))
            if os.path.exists(candidate):
                return candidate
        # Not found; return original
        return path

    def _get_relative_path_for_nsi(self, file_path: str, nsi_dir: str = None) -> str:
        """Convert absolute file path to relative path suitable for NSIS script.
        
        If file is in the same directory as the .nsi file, returns just the filename.
        Otherwise returns the path relative to the .nsi directory.
        
        Args:
            file_path: Absolute or relative path to the file
            nsi_dir: Directory where .nsi file is located. If None, uses config._config_dir
            
        Returns:
            Path suitable for inclusion in NSIS script (forward slashes converted to backslashes)
        """
        if not file_path:
            return file_path
            
        # Resolve to absolute path
        abs_path = self._resolve_path_relative_to_config(file_path)
        
        # Get NSIS output directory (config directory by default)
        if nsi_dir is None:
            nsi_dir = getattr(self.config, '_config_dir', os.getcwd())
        
        # Compute relative path from .nsi directory to file
        try:
            rel_path = os.path.relpath(abs_path, nsi_dir)
            # Normalize path for NSIS (forward slashes to backslashes)
            rel_path = rel_path.replace('/', '\\')
            return rel_path
        except ValueError:
            # Different drives on Windows - return as-is with backslashes
            return abs_path.replace('/', '\\')

    def _generate_general_settings(self) -> List[str]:
        """Generate general NSIS settings"""
        lines = [
            "; General Settings",
            f'Name "${{APP_NAME}}"',
            f'OutFile "${{APP_NAME}}-${{APP_VERSION}}-Setup.exe"',
            f'InstallDir "{self._interpolate_yaml_placeholders(self.config.install.install_dir)}"',
            'InstallDirRegKey HKLM "${REG_KEY}" "InstallPath"',
            'RequestExecutionLevel admin',
        ]
        
        # Add license if specified - use relative path for NSIS
        if self.config.app.license:
            abs_license_path = self._resolve_path_relative_to_config(self.config.app.license)
            if os.path.exists(abs_license_path):
                rel_license_path = self._get_relative_path_for_nsi(abs_license_path)
                lines.append(f'!define LICENSE_FILE "{rel_license_path}"')
                lines.append(f'LicenseData "${{LICENSE_FILE}}"')
            else:
                lines.append(f'; Warning: License file not found: {self.config.app.license}')
                lines.append(f'!define LICENSE_FILE "{self.config.app.license}"')
                lines.append(f'LicenseData "${{LICENSE_FILE}}"')
        
        lines.append("")
        return lines
    
    def _generate_modern_ui(self) -> List[str]:
        """Generate Modern UI configuration"""
        lines = [
            "; Modern UI",
            '!include "MUI2.nsh"',
            "",
            "; UI Pages",
            "!insertmacro MUI_PAGE_LICENSE \"${LICENSE_FILE}\"" if self.config.app.license else "; No license page",
        ]
        
        # Add components page if packages are defined
        if self.config.packages:
            lines.append("!insertmacro MUI_PAGE_COMPONENTS")
        
        lines.extend([
            "!insertmacro MUI_PAGE_DIRECTORY",
            "!insertmacro MUI_PAGE_INSTFILES",
            "!insertmacro MUI_PAGE_FINISH",
            "",
            "!insertmacro MUI_UNPAGE_CONFIRM",
            "!insertmacro MUI_UNPAGE_INSTFILES",
            "",
            "!insertmacro MUI_LANGUAGE \"English\"",
            "",
        ])
        return lines
    
    def _generate_installer_section(self) -> List[str]:
        """Generate installer section"""
        lines = [
            "; Installer Section",
            "Section \"Install\"",
            "",
            "  SetOutPath $INSTDIR",
            "",
        ]
        
        # Add files
        for file_entry in self.config.files:
            normalized_source = self._normalize_path(file_entry.source)
            if file_entry.recursive:
                lines.append(f'  File /r "{normalized_source}"')
            else:
                lines.append(f'  File "{normalized_source}"')
            if file_entry.destination != "$INSTDIR":
                lines.append(f'  ; Install to: {file_entry.destination}')
        
        lines.extend([
            "",
            "  ; Write uninstaller",
            '  WriteUninstaller "$INSTDIR\\Uninstall.exe"',
            "",
        ])
        
        # Registry entries
        lines.extend([
            "  ; Registry entries",
            '  WriteRegStr HKLM "${REG_KEY}" "InstallPath" "$INSTDIR"',
            '  WriteRegStr HKLM "${REG_KEY}" "Version" "${APP_VERSION}"',
            '  WriteRegStr HKLM "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${APP_NAME}" "DisplayName" "${APP_NAME}"',
            '  WriteRegStr HKLM "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${APP_NAME}" "UninstallString" "$INSTDIR\\Uninstall.exe"',
            '  WriteRegStr HKLM "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${APP_NAME}" "DisplayVersion" "${APP_VERSION}"',
            '  WriteRegStr HKLM "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${APP_NAME}" "Publisher" "${APP_PUBLISHER}"',
            "",
        ])
        
        # Desktop shortcut
        if self.config.install.create_desktop_shortcut:
            lines.extend([
                "  ; Create desktop shortcut",
                '  CreateShortCut "$DESKTOP\\${APP_NAME}.lnk" "$INSTDIR\\${APP_NAME}.exe"',
                "",
            ])
        
        # Start menu shortcut
        if self.config.install.create_start_menu_shortcut:
            lines.extend([
                "  ; Create start menu shortcuts",
                '  CreateDirectory "$SMPROGRAMS\\${APP_NAME}"',
                '  CreateShortCut "$SMPROGRAMS\\${APP_NAME}\\${APP_NAME}.lnk" "$INSTDIR\\${APP_NAME}.exe"',
                '  CreateShortCut "$SMPROGRAMS\\${APP_NAME}\\Uninstall.lnk" "$INSTDIR\\Uninstall.exe"',
                "",
            ])
        
        lines.append("SectionEnd")
        lines.append("")
        
        return lines
    
    def _generate_uninstaller_section(self) -> List[str]:
        """Generate uninstaller section"""
        lines = [
            "; Uninstaller Section",
            "Section \"Uninstall\"",
            "",
            "  ; Remove files",
        ]
        
        # Remove files from regular files list (in reverse order)
        for file_entry in reversed(self.config.files):
            filename = os.path.basename(file_entry.source)
            if file_entry.recursive:
                # For recursive, remove the directory
                dirname = os.path.basename(file_entry.source.rstrip('/\\'))
                lines.append(f'  RMDir /r "$INSTDIR\\{dirname}"')
            else:
                lines.append(f'  Delete "$INSTDIR\\{filename}"')
        
        lines.extend([
            "",
            "  ; Remove uninstaller",
            '  Delete "$INSTDIR\\Uninstall.exe"',
            "",
            "  ; Remove install directory",
            '  RMDir "$INSTDIR"',
            "",
        ])
        
        # Remove shortcuts
        if self.config.install.create_desktop_shortcut:
            lines.extend([
                "  ; Remove desktop shortcut",
                '  Delete "$DESKTOP\\${APP_NAME}.lnk"',
                "",
            ])
        
        if self.config.install.create_start_menu_shortcut:
            lines.extend([
                "  ; Remove start menu shortcuts",
                '  Delete "$SMPROGRAMS\\${APP_NAME}\\${APP_NAME}.lnk"',
                '  Delete "$SMPROGRAMS\\${APP_NAME}\\Uninstall.lnk"',
                '  RMDir "$SMPROGRAMS\\${APP_NAME}"',
                "",
            ])
        
        # Remove registry entries
        lines.extend([
            "  ; Remove registry entries",
            '  DeleteRegKey HKLM "${REG_KEY}"',
            '  DeleteRegKey HKLM "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${APP_NAME}"',
            "",
            "SectionEnd",
            "",
        ])
        
        return lines
    
    def _generate_signing_section(self) -> List[str]:
        """Generate code signing commands"""
        if not self.config.signing or not self.config.signing.enabled:
            return []
        
        lines = [
            "; Code Signing Configuration",
            f'; Certificate: {self.config.signing.certificate}',
            f'; Timestamp: {self.config.signing.timestamp_url}',
            "; Note: Use !finalize to sign the installer after build",
            f'!finalize \'signtool sign /f "{self.config.signing.certificate}" /p "{self.config.signing.password}" /t "{self.config.signing.timestamp_url}" "%1"\'',
            "",
        ]
        return lines
    
    def _generate_update_section(self) -> List[str]:
        """Generate auto-update configuration"""
        if not self.config.update or not self.config.update.enabled:
            return []
        
        lines = [
            "; Auto-Update Configuration",
            f'!define UPDATE_URL "{self.config.update.update_url}"',
            f'!define CHECK_ON_STARTUP "{str(self.config.update.check_on_startup).lower()}"',
            "",
            "; Note: Auto-update logic should be implemented in the application",
            "; The installer only sets registry values for the application to read",
            "Section \"Update Configuration\"",
            '  WriteRegStr HKLM "${REG_KEY}" "UpdateURL" "${UPDATE_URL}"',
            '  WriteRegStr HKLM "${REG_KEY}" "CheckOnStartup" "${CHECK_ON_STARTUP}"',
            "SectionEnd",
            "",
        ]
        return lines
    
    def _generate_package_sections(self) -> List[str]:
        """Generate sections for each package/component"""
        if not self.config.packages:
            return []
        
        lines = [
            "; Package/Component Sections",
            "",
        ]
        
        def _make_file_line(pkg_entry, s):
            resolved = self._resolve_path_relative_to_config(s)
            if os.path.exists(resolved):
                path_for_nsi = resolved
            else:
                path_for_nsi = self._normalize_path(s)
            if pkg_entry.recursive:
                return f'  File /r "{path_for_nsi}"'
            return f'  File "{path_for_nsi}"'

        def _emit_package_section(pkg_entry, sec_name):
            lines.append(f'Section "{pkg_entry.name}" {sec_name}')
            for source_entry in pkg_entry.sources:
                source_value = source_entry.get("source", "")
                dest_path = source_entry.get("destination", "$INSTDIR")
                lines.append(f'  SetOutPath "{dest_path}"')

                if isinstance(source_value, list):
                    for s in source_value:
                        lines.append(_make_file_line(pkg_entry, s))
                else:
                    lines.append(_make_file_line(pkg_entry, source_value))
            lines.append("SectionEnd")
            lines.append("")

        def _emit_group_or_section(pkg_list, idx_ref):
            for pkg_entry in pkg_list:
                if pkg_entry.children:
                    lines.append(f'SectionGroup "{pkg_entry.name}"')
                    _emit_group_or_section(pkg_entry.children, idx_ref)
                    lines.append("SectionGroupEnd")
                    lines.append("")
                else:
                    sec_name = f"SEC_PKG_{idx_ref[0]}"
                    idx_ref[0] += 1
                    _emit_package_section(pkg_entry, sec_name)

        _emit_group_or_section(self.config.packages, [0])
        return lines
    
    def _generate_section_initialization(self) -> List[str]:
        """Generate initialization code for section flags (optional, default settings)"""
        if not self.config.packages:
            return []
        
        lines = [
            "; Section Flags - Control default selection state",
            "Function .onInit",
            "",
        ]
        
        for idx, pkg in enumerate(self._flatten_packages(self.config.packages)):
            sec_name = f"SEC_PKG_{idx}"
            if pkg.optional and not pkg.default:
                # Optional and NOT default -> unselect by default
                lines.append(f'  SectionSetFlags ${{{sec_name}}} 0')
            elif not pkg.optional:
                # Required -> keep selected
                lines.append(f'  SectionSetFlags ${{{sec_name}}} ${{SF_SELECTED}}')
        
        lines.extend([
            "FunctionEnd",
            "",
        ])
        
        return lines

    def _flatten_packages(self, packages):
        """Return leaf packages in traversal order (ignore groups)."""
        flat = []
        for pkg in packages:
            if pkg.children:
                flat.extend(self._flatten_packages(pkg.children))
            else:
                flat.append(pkg)
        return flat
    
    def _generate_custom_includes(self) -> List[str]:
        """Generate custom NSIS includes"""
        if not self.config.custom_nsis_includes:
            return []
        
        lines = [
            "; Custom NSIS Includes",
        ]
        for include_file in self.config.custom_nsis_includes:
            lines.append(f'!include "{include_file}"')
        lines.append("")
        
        return lines
    
    def convert(self) -> str:
        """Convert YAML configuration to NSIS script"""
        nsis_lines = []
        
        # Add all sections
        nsis_lines.extend(self._generate_header())
        nsis_lines.extend(self._generate_custom_includes())
        nsis_lines.extend(self._generate_general_settings())
        nsis_lines.extend(self._generate_modern_ui())
        nsis_lines.extend(self._generate_signing_section())
        nsis_lines.extend(self._generate_update_section())
        nsis_lines.extend(self._generate_installer_section())
        nsis_lines.extend(self._generate_package_sections())
        nsis_lines.extend(self._generate_uninstaller_section())
        nsis_lines.extend(self._generate_section_initialization())
        
        return "\n".join(nsis_lines)
    
    def save(self, output_path: str) -> None:
        """Save NSIS script to file"""
        nsis_script = self.convert()
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(nsis_script)
