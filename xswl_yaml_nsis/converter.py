"""
YAML to NSIS script converter
"""

import os
from typing import List
from .config import PackageConfig


class YamlToNsisConverter:
    """Converts YAML configuration to NSIS script"""
    
    def __init__(self, config: PackageConfig):
        self.config = config
    
    def _replace_variables(self, text: str) -> str:
        """Replace variable placeholders with actual values"""
        replacements = {
            "${APP_NAME}": self.config.app.name,
            "${APP_VERSION}": self.config.app.version,
            "${APP_PUBLISHER}": self.config.app.publisher,
        }
        for var, value in replacements.items():
            text = text.replace(var, value)
        return text
    
    def _generate_header(self) -> List[str]:
        """Generate NSIS header section"""
        lines = [
            "; NSIS Script generated by xswl-yaml-nsis",
            "; Do not edit manually - regenerate from YAML configuration",
            "",
            "; Application Information",
            f'!define APP_NAME "{self.config.app.name}"',
            f'!define APP_VERSION "{self.config.app.version}"',
            f'!define APP_PUBLISHER "{self.config.app.publisher}"',
            f'!define APP_DESCRIPTION "{self.config.app.description}"',
            f'!define REG_KEY "Software\\{self.config.app.name}"',
        ]
        
        # Add license file define if specified
        if self.config.app.license:
            lines.append(f'!define LICENSE_FILE "{self.config.app.license}"')
        
        lines.append("")
        return lines
    
    def _generate_general_settings(self) -> List[str]:
        """Generate general NSIS settings"""
        lines = [
            "; General Settings",
            f'Name "${{APP_NAME}}"',
            f'OutFile "${{APP_NAME}}-${{APP_VERSION}}-Setup.exe"',
            f'InstallDir "{self._replace_variables(self.config.install.install_dir)}"',
            'InstallDirRegKey HKLM "${REG_KEY}" "InstallPath"',
            'RequestExecutionLevel admin',
        ]
        
        # Add icon if specified
        if self.config.app.icon:
            lines.append(f'Icon "{self.config.app.icon}"')
            lines.append(f'UninstallIcon "{self.config.app.icon}"')
        
        # Add license if specified
        if self.config.app.license:
            lines.append(f'LicenseData "${{LICENSE_FILE}}"')
        
        lines.append("")
        return lines
    
    def _generate_modern_ui(self) -> List[str]:
        """Generate Modern UI configuration"""
        lines = [
            "; Modern UI",
            '!include "MUI2.nsh"',
            "",
            "; UI Pages",
            "!insertmacro MUI_PAGE_LICENSE \"${LICENSE_FILE}\"" if self.config.app.license else "; No license page",
            "!insertmacro MUI_PAGE_DIRECTORY",
            "!insertmacro MUI_PAGE_INSTFILES",
            "!insertmacro MUI_PAGE_FINISH",
            "",
            "!insertmacro MUI_UNPAGE_CONFIRM",
            "!insertmacro MUI_UNPAGE_INSTFILES",
            "",
            "!insertmacro MUI_LANGUAGE \"English\"",
            "",
        ]
        return lines
    
    def _generate_installer_section(self) -> List[str]:
        """Generate installer section"""
        lines = [
            "; Installer Section",
            "Section \"Install\"",
            "",
            "  SetOutPath $INSTDIR",
            "",
        ]
        
        # Add files
        for file_entry in self.config.files:
            if file_entry.recursive:
                lines.append(f'  File /r "{file_entry.source}"')
            else:
                lines.append(f'  File "{file_entry.source}"')
            if file_entry.destination != "$INSTDIR":
                lines.append(f'  ; Install to: {file_entry.destination}')
        
        lines.extend([
            "",
            "  ; Write uninstaller",
            '  WriteUninstaller "$INSTDIR\\Uninstall.exe"',
            "",
        ])
        
        # Registry entries
        lines.extend([
            "  ; Registry entries",
            '  WriteRegStr HKLM "${REG_KEY}" "InstallPath" "$INSTDIR"',
            '  WriteRegStr HKLM "${REG_KEY}" "Version" "${APP_VERSION}"',
            '  WriteRegStr HKLM "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${APP_NAME}" "DisplayName" "${APP_NAME}"',
            '  WriteRegStr HKLM "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${APP_NAME}" "UninstallString" "$INSTDIR\\Uninstall.exe"',
            '  WriteRegStr HKLM "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${APP_NAME}" "DisplayVersion" "${APP_VERSION}"',
            '  WriteRegStr HKLM "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${APP_NAME}" "Publisher" "${APP_PUBLISHER}"',
            "",
        ])
        
        # Desktop shortcut
        if self.config.install.create_desktop_shortcut:
            lines.extend([
                "  ; Create desktop shortcut",
                '  CreateShortCut "$DESKTOP\\${APP_NAME}.lnk" "$INSTDIR\\${APP_NAME}.exe"',
                "",
            ])
        
        # Start menu shortcut
        if self.config.install.create_start_menu_shortcut:
            lines.extend([
                "  ; Create start menu shortcuts",
                '  CreateDirectory "$SMPROGRAMS\\${APP_NAME}"',
                '  CreateShortCut "$SMPROGRAMS\\${APP_NAME}\\${APP_NAME}.lnk" "$INSTDIR\\${APP_NAME}.exe"',
                '  CreateShortCut "$SMPROGRAMS\\${APP_NAME}\\Uninstall.lnk" "$INSTDIR\\Uninstall.exe"',
                "",
            ])
        
        lines.append("SectionEnd")
        lines.append("")
        
        return lines
    
    def _generate_uninstaller_section(self) -> List[str]:
        """Generate uninstaller section"""
        lines = [
            "; Uninstaller Section",
            "Section \"Uninstall\"",
            "",
            "  ; Remove files",
        ]
        
        # Remove files (in reverse order)
        for file_entry in reversed(self.config.files):
            filename = os.path.basename(file_entry.source)
            if file_entry.recursive:
                # For recursive, remove the directory
                dirname = os.path.basename(file_entry.source.rstrip('/\\'))
                lines.append(f'  RMDir /r "$INSTDIR\\{dirname}"')
            else:
                lines.append(f'  Delete "$INSTDIR\\{filename}"')
        
        lines.extend([
            "",
            "  ; Remove uninstaller",
            '  Delete "$INSTDIR\\Uninstall.exe"',
            "",
            "  ; Remove install directory",
            '  RMDir "$INSTDIR"',
            "",
        ])
        
        # Remove shortcuts
        if self.config.install.create_desktop_shortcut:
            lines.extend([
                "  ; Remove desktop shortcut",
                '  Delete "$DESKTOP\\${APP_NAME}.lnk"',
                "",
            ])
        
        if self.config.install.create_start_menu_shortcut:
            lines.extend([
                "  ; Remove start menu shortcuts",
                '  Delete "$SMPROGRAMS\\${APP_NAME}\\${APP_NAME}.lnk"',
                '  Delete "$SMPROGRAMS\\${APP_NAME}\\Uninstall.lnk"',
                '  RMDir "$SMPROGRAMS\\${APP_NAME}"',
                "",
            ])
        
        # Remove registry entries
        lines.extend([
            "  ; Remove registry entries",
            '  DeleteRegKey HKLM "${REG_KEY}"',
            '  DeleteRegKey HKLM "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${APP_NAME}"',
            "",
            "SectionEnd",
            "",
        ])
        
        return lines
    
    def _generate_signing_section(self) -> List[str]:
        """Generate code signing commands"""
        if not self.config.signing or not self.config.signing.enabled:
            return []
        
        lines = [
            "; Code Signing Configuration",
            f'; Certificate: {self.config.signing.certificate}',
            f'; Timestamp: {self.config.signing.timestamp_url}',
            "; Note: Use !finalize to sign the installer after build",
            f'!finalize \'signtool sign /f "{self.config.signing.certificate}" /p "{self.config.signing.password}" /t "{self.config.signing.timestamp_url}" "%1"\'',
            "",
        ]
        return lines
    
    def _generate_update_section(self) -> List[str]:
        """Generate auto-update configuration"""
        if not self.config.update or not self.config.update.enabled:
            return []
        
        lines = [
            "; Auto-Update Configuration",
            f'!define UPDATE_URL "{self.config.update.update_url}"',
            f'!define CHECK_ON_STARTUP "{str(self.config.update.check_on_startup).lower()}"',
            "",
            "; Note: Auto-update logic should be implemented in the application",
            "; The installer only sets registry values for the application to read",
            "Section \"Update Configuration\"",
            '  WriteRegStr HKLM "${REG_KEY}" "UpdateURL" "${UPDATE_URL}"',
            '  WriteRegStr HKLM "${REG_KEY}" "CheckOnStartup" "${CHECK_ON_STARTUP}"',
            "SectionEnd",
            "",
        ]
        return lines
    
    def _generate_custom_includes(self) -> List[str]:
        """Generate custom NSIS includes"""
        if not self.config.custom_nsis_includes:
            return []
        
        lines = [
            "; Custom NSIS Includes",
        ]
        for include_file in self.config.custom_nsis_includes:
            lines.append(f'!include "{include_file}"')
        lines.append("")
        
        return lines
    
    def convert(self) -> str:
        """Convert YAML configuration to NSIS script"""
        nsis_lines = []
        
        # Add all sections
        nsis_lines.extend(self._generate_header())
        nsis_lines.extend(self._generate_custom_includes())
        nsis_lines.extend(self._generate_general_settings())
        nsis_lines.extend(self._generate_modern_ui())
        nsis_lines.extend(self._generate_signing_section())
        nsis_lines.extend(self._generate_update_section())
        nsis_lines.extend(self._generate_installer_section())
        nsis_lines.extend(self._generate_uninstaller_section())
        
        return "\n".join(nsis_lines)
    
    def save(self, output_path: str) -> None:
        """Save NSIS script to file"""
        nsis_script = self.convert()
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(nsis_script)
